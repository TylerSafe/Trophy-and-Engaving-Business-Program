import tkinter as tk
import tkinter.ttk as ttk
from tkinter import *
import os
from openpyxl import load_workbook
from openpyxl import Workbook
from PIL import Image, ImageDraw
from datetime import date
from docx import Document
from docx.shared import Cm, Pt
import string
import random
import shutil

PATH = os.path.abspath(".") # path to the folder containing the python file
FONT = 'GoogleSans 11' # font used throughout the application
ENTRY_COLOUR = '#6e6d6d' # colour of entry field text

# class that loads the initial window and handles styles/interactions
class Window:
    def __init__(self, master):
        frame = Frame(master, bg='white')

        # load classes
        self.signature = Signature(frame)
        self.sheet = JobSheets(frame, master)
        self.word_doc = WordDoc(self.sheet)
        self.cus_history = CustomerHistory(frame, self.word_doc)
        self.cus_search = CustomerDetails(frame, self, self.cus_history, self.word_doc)
        self.calendar = Calendar(frame, self, self.word_doc)

        # create heading
        self.heading = PhotoImage(file=PATH + '\\Resources\\Images\\heading_image.png')
        self.heading_label = Label(frame, image=self.heading, border=0)
        self.heading_label.grid(row=0, column=1, padx=(100,0), pady=0, rowspan=2, columnspan=1, sticky=NW)

        # create clear all button
        self.clear_image = PhotoImage(file=PATH + '\\Resources\\Images\\button_clear_all.png')
        self.clear_button = Button(frame, image=self.clear_image, command=self.clear_all, border=0, bg='white', highlightthickness=0)
        self.clear_button.grid(row=0, column=1, padx=(570, 0), pady=(600, 0), sticky=NW)
        
        frame.grid()

    # clear all entry fields
    def clear_all(self):
        self.signature.clear_signature()
        self.sheet.clear_entries()
        self.cus_search.clear_cus_entries()
        self.cus_search.search_entry.delete(0, END)
        self.cus_search.update_listbox([])
        self.cus_history.clear_history()

    # create a pop up window, used for error messages, confirmation messages, displaying notes
    def pop_up_window(self, message, title):
        self.new_window = Toplevel()
        self.new_window.title(title)
        self.new_window.geometry('')
        self.new_window.configure(background='white')
        self.new_window.iconbitmap(PATH + '\\Resources\\Images\\logo.ico')

        # set the image to be displayed based on the title of the window (easier to do here than each time the function is called)
        if title == 'Error':
            self.image = PhotoImage(file=PATH + '\\Resources\\Images\\error_cross.png')
        elif title == 'Confirmation':
            self.image = PhotoImage(file=PATH + '\\Resources\\Images\\confirm_tick.png')
        else:
            self.image = PhotoImage(file=PATH + '\\Resources\\Images\\note_image.png')

        # display an image along with the message
        self.image_label = Label(self.new_window, image=self.image, border=0)
        self.image_label.grid(row=0, column=0, padx=(15, 0), pady=15, sticky=E)
        self.message_label = Label(self.new_window, text=message, font=FONT, bg='white')
        self.message_label.grid(row=0, column=1, padx=(5, 15), pady=(15, 15), sticky=W)

        # create an ok button as another way to close the window when clicked
        self.button_image = PhotoImage(file=PATH + '\\Resources\\Images\\button_ok.png')
        self.ok_button = Button(self.new_window, image=self.button_image, command=self.new_window.destroy, border=0, bg='white', highlightthickness=0)
        self.ok_button.grid(row=1, column=0, columnspan=2, padx=10, pady=(5, 15), sticky=N)

        self.new_window.attributes('-topmost', 'true')
        self.center(self.new_window)

    # give the customer a choice between two options (ok/cancel)
    def option_message(self, message, function):
        self.option = Toplevel()
        self.option.title('Confirmation')
        self.option.geometry('')
        self.option.configure(background='white')
        self.option.iconbitmap(PATH + '\\Resources\\Images\\logo.ico')

        self.option_label = Label(self.option, text=message, font=FONT, bg='white')
        self.option_label.grid(row=0, column=0, padx=(15, 15), pady=15, columnspan=2, sticky=W)

        self.button_ok = PhotoImage(file=PATH + '\\Resources\\Images\\button_ok.png')
        if function == 'delete':
            self.ok_button = Button(self.option, image=self.button_ok, command=lambda:(self.cus_search.del_cus(), self.option.destroy()), border=0, bg='white', highlightthickness=0)
        elif function == 'edit':
            self.ok_button = Button(self.option, image=self.button_ok, command=lambda:(self.cus_search.edit_cus(), self.option.destroy()), border=0, bg='white', highlightthickness=0)
        self.ok_button.grid(row=1, column=0, padx=(0,10), pady=(5, 15), sticky=E)

        self.button_cancel = PhotoImage(file=PATH + '\\Resources\\Images\\button_cancel.png')
        self.cancel_button = Button(self.option, image=self.button_cancel, command=self.option.destroy, border=0, bg='white', highlightthickness=0)
        self.cancel_button.grid(row=1, column=1, padx=(10,0), pady=(5, 15), sticky=W)

        self.option.attributes('-topmost', 'true')
        self.center(self.option)

    # center any windows that pop up on the screen
    def center(self, win):
        win.update_idletasks()
        width = win.winfo_width()
        frm_width = win.winfo_rootx() - win.winfo_x()
        win_width = width + 2 * frm_width
        height = win.winfo_height()
        titlebar_height = win.winfo_rooty() - win.winfo_y()
        win_height = height + titlebar_height + frm_width
        x = win.winfo_screenwidth() // 2 - win_width // 2
        y = win.winfo_screenheight() // 2 - win_height // 2
        win.geometry('{}x{}+{}+{}'.format(width, height, x, y))
        win.deiconify()  

# class that implements calendar functionality, assigning sheets to dates, sending notifications, etc.
class Calendar:
    def __init__(self, frame, window, word_doc):
        self.frame = frame
        self.window = window
        self.word_doc = word_doc

        # button that creates the trophy sheet entries/labels
        self.cal_image = PhotoImage(file=PATH + '\\Resources\\Images\\calendar_button.png')
        self.calendar_button = Button(frame, image=self.cal_image, command=self.open_calendar, border=0, bg='white', highlightthickness=0)
        self.calendar_button.grid(row=0, column=1, padx=(353,0), pady=(150, 0), sticky=NW)

    # create the calendar window
    def open_calendar(self):        
        self.cal_window = Toplevel()
        height = 500
        width = 900
        self.cal_window.title("Calendar")
        self.cal_window.geometry('900x500')
        self.cal_window.configure(background='white')
        self.cal_window.iconbitmap(PATH + '\\Resources\\Images\\logo.ico')

        # add a scrollbar to the window
        main_frame = Frame(self.cal_window, width=width, height=height)
        main_frame.place(x=0,y=0)

        my_canvas = Canvas(main_frame, width=width, height=height)
        my_canvas.place(x=0,y=0)
        
        my_scrollbar = ttk.Scrollbar(main_frame, orient=VERTICAL, command=my_canvas.yview)
        my_scrollbar.place(x=880, y=0, height=height)

        my_canvas.configure(yscrollcommand=my_scrollbar.set)
        my_canvas.bind('<Configure>', lambda e: my_canvas.configure(scrollregion = my_canvas.bbox("all")))
        
        def _on_mouse_wheel(event):
            my_canvas.yview_scroll(-1 * int((event.delta / 120)), "units")
        
        my_canvas.bind_all("<MouseWheel>", _on_mouse_wheel)
        
        self.second_frame = Frame(my_canvas,width=width,height=135)
        self.second_frame.place(x=0,y=0) 
        
        my_canvas.create_window((0,0), window=self.second_frame, anchor="nw")

        self.load_calendar()

        self.window.center(self.cal_window)

    # load details from excel file
    def load_calendar(self):
        if not os.path.exists(PATH + '\\Data\\Original\\calendar.xlsx'):
            wb = Workbook()
            wb.save(PATH + '\\Data\\Original\\calendar.xlsx')
            wb.close()

        # get relevant information from excel file
        wb = load_workbook(PATH + '\\Data\\Original\\calendar.xlsx')
        ws = wb['Sheet']
        date = ws['A']
        search_name = ws['B']
        name = ws['C']
        notes = ws['D']
        contact1 = ws['E']
        contact2 = ws['F']
        contact3 = ws['G']
        date_fixed = []

        # get every row of data
        date1 = [date[x].value for x in range(len(name))]
        del date1[0]
        search_name1 = [search_name[x].value for x in range(len(name))]
        del search_name1[0]
        name1 = [name[x].value for x in range(len(name))]
        del name1[0]
        notes1 = [notes[x].value for x in range(len(name))]
        del notes1[0]
        contact1x = [contact1[x].value for x in range(len(name))]
        del contact1x[0]
        contact2x = [contact2[x].value for x in range(len(name))]
        del contact2x[0]
        contact3x = [contact3[x].value for x in range(len(name))]
        del contact3x[0]

        # clean up the date for easy sorting
        for i in range(len(date1)):
            date = self.clean_date(date1[i])
            date_fixed.append(date)

        # sort all lists by date
        try:
            date_fixed, search_name1, name1, contact1x, contact2x, contact3x, notes1 = (list(t) for t in zip(*sorted(zip(date_fixed, search_name1, name1, contact1x, contact2x, contact3x, notes1))))
        except:
            self.window.pop_up_window('Error! No calendar information available', 'Error')

        # format calendar display
        calendar_heading = Label(self.second_frame, text = 'Calendar')
        calendar_heading.config(font =("Courier bold", 18))
        calendar_heading.place(x = 20, y = 10)

        if len(date_fixed) != 0:
            # figure out if there is a required by date in order to place the heading
            if date_fixed[0] == '00000000' or self.readable_date(date_fixed[0]) == 'incorrect date format':
                heading = Label(self.second_frame, text = 'No Required by Date')
                heading.config(font =("Courier", 15))
                heading.place(x = 20, y = 70)
            else:
                heading = Label(self.second_frame, text = self.readable_date(date_fixed[0]))
                heading.config(font =("Courier", 15))
                heading.place(x = 20, y = 70)

        position = 0

        # loop through all orders in the calendar and display them along with the buttons for functionality
        for i in range(len(date_fixed)):
            order_button = Button(self.second_frame, width = 33, bg='#e1e5eb', text=name1[i], command = lambda i=i: self.word_doc.open_doc(search_name1[i], name1[i]))
            order_button.place(x = 70, y = 96 + (i * 26) + position)
            
            # if there is a note attached to the order change the colour of the button to indicate there is a note
            if notes1[i] != None:
                notes = Button(self.second_frame, width = 10, bg='#B3B7BC', text='Notes', command = lambda i=i: self.view_note(search_name1[i], ws))
            else:
                notes = Button(self.second_frame, width = 10, bg='#e1e5eb', text='Notes', command = lambda i=i: self.view_note(search_name1[i], ws))
            
            notes.place(x = 320, y = 96 + (i * 26) + position)

            add_note = Button(self.second_frame, width = 10, bg='#e1e5eb', text='Add Note', command = lambda i=i: self.add_note(search_name1[i], ws, wb))
            add_note.place(x = 400, y = 96 + (i * 26) + position)

            add_contact = Button(self.second_frame, width = 10, bg='#e1e5eb', text='Add Contact', command = lambda i=i: self.edit_contact(search_name1[i], ws, wb, 'add'))
            add_contact.place(x = 490, y = 96 + (i * 26) + position)

            remove_contact = Button(self.second_frame, width = 13, bg='#e1e5eb', text='Remove Contact', command = lambda i=i: self.edit_contact(search_name1[i], ws, wb, 'remove'))
            remove_contact.place(x = 570, y = 96 + (i * 26) + position)

            change_date = Button(self.second_frame, width = 10, bg='#e1e5eb', text='Change Date', command = lambda i=i: self.change_date(search_name1[i], name1[i], ws, wb))
            change_date.place(x = 680, y = 96 + (i * 26) + position)
            
            complete_button = Button(self.second_frame, width = 10, bg='#e1e5eb', text='Complete', command = lambda i=i: removeOrder(new_window, search_name1[i], ws, wb))
            complete_button.place(x = 770, y = 96 + (i * 26) + position)
            
            # determine if a team member is assigned to the order, if so display thier colour next to the order
            if contact1x[i] != None and contact1x[i] != ' ':
                self.set_contact(self.second_frame, contact1x[i], 23, 101 + (i * 26) + position)
            if contact2x[i] != None and contact2x[i] != ' ':
                self.set_contact(self.second_frame, contact2x[i], 35, 101 + (i * 26) + position)
            if contact3x[i] != None and contact3x[i] != ' ':
                self.set_contact(self.second_frame, contact3x[i], 47, 101 + (i * 26) + position)

            # add height for the scroll bar area
            self.second_frame.configure(height=135 + (i * 26) + position)
            
            # check if the next order has a different date, if so display the new date, otherwise keep it under the same heading
            if i != len(date_fixed) - 1 and date_fixed[i] != date_fixed[i + 1] and self.readable_date(date_fixed[i + 1]) != 'incorrect date format':
                heading = Label(self.second_frame, text = self.readable_date(date_fixed[i + 1]))
                heading.config(font =("Courier", 15))
                position += 35
                heading.place(x = 20, y = 96 + (i * 26) + position)
                self.second_frame.configure(height=135 + (i * 26) + position)

        wb.close()

    # edit word doc with the new required by date
    def change_required(self, search_name, name, date): 
        try:
            if search_name[0] == 'T':
                path = PATH + '\\1. Job Sheets\\Trophy Jobsheets\\' + name + '\\' + search_name + '.docx'            
        
            elif search_name[0] == 'E':
                path = PATH + '\\1. Job Sheets\\Engraving Jobsheets\\' + name + '\\' + search_name + '.docx'
                
            document = Document(path)

            for paragraph in document.paragraphs:
                if '    Required by: ' in paragraph.text:
                    paragraph.text = ''
                    paragraph.alignment = 1
                    paragraph.paragraph_format.space_before = Pt(1)
                    f7 = paragraph.add_run('    Required by: ')
                    font = f7.font
                    font.size = Pt(14)
                    f7.bold = True
                    f8 = paragraph.add_run(date)
                    font = f8.font
                    font.size = Pt(14)

            document.save(path)
        except:
            self.window.pop_up_window('Unable to find word document', 'Error')

    # change the required by date of a selected order in the calendar excel file
    def submit_date(self, new_window, search_name, name, date_entry, ws, wb):
        row = ws.max_row
        date = self.clean_date(date_entry)
        date_done = self.readable_date(date)
            
        for i in range(1, row + 1):
            if ws.cell(column=2, row=i).value == search_name:
                ws.cell(column=1, row=i, value=date_done)
                break

        wb.save(PATH + '\\Data\\Original\\calendar.xlsx')

        self.change_required(search_name, name, date_done)

        new_window.destroy()
        self.cal_window.destroy()
        self.open_calendar()
        self.window.pop_up_window('Successfully changed the required by date', 'Confirmation')
    
    # create window to change the required by date of a selected order
    def change_date(self, search_name, name, ws, wb):
        new_window = Toplevel()
        new_window.title("Change Date")
        new_window.geometry("460x110")

        date_label = Label(new_window, text = "New Required By Date (DD/MM/YYYY):", font=FONT)
        date_label.place(x = 20, y = 10)

        date_entry = Entry(new_window, width = 25)
        date_entry.place(x = 145, y = 40)

        submit_button = Button(new_window, width = 10, bg='#e1e5eb', text='Submit', command = lambda: self.submit_date(new_window, search_name, name, date_entry.get(), ws, wb))
        submit_button.place(x = 185, y = 70)

        self.window.center(new_window)
    
    # clean up the date for easy sorting
    def clean_date(self, date):     
        if date is not None:  
            if '/' in date[0:2]:
                date = '0' + date      
            if '/' in date[3:5]:
                date = date[0:3] + '0' + date[3:len(date)]
            if len(date) == 8:
                date = date[0:6] + '20' + date[6:8]

            date = date.replace('/', '')

            day = date[0:2]
            month = date[2:4]
            year = date[4:8]

            return year + month + day
        else:
            date = '00000000'
        return date

    # change date format for display
    def readable_date(self, date):
        if len(date) == 8:
            day = date[6:8]
            month = date[4:6]
            year = date[0:4]

            return day + '/' + month + '/' + year
        else:
            return 'incorrect date format'

    # set the coloured square for the team member
    def set_contact(self, window, contact, x, y):   
        if contact.lower() == 'kurt':
            square = Label(window, bg = '#4CE020', width = 1)
        elif contact.lower() == 'vanessa':
            square = Label(window, bg = '#A331DC', width = 1)
        elif contact.lower() == 'di':
            square = Label(window, bg = '#e9f026', width = 1)
        elif contact.lower() == 'sophie':
            square = Label(window, bg = '#f21be7', width = 1)
        elif contact.lower() == 'workshop':
            square = Label(window, bg = '#247ef2', width = 1)
        elif contact.lower() == 'service':
            square = Label(window, bg = '#1bd5f2', width = 1)
        else:
            square = Label(window, bg = '#DF4027', width = 1)

        square.config(font =("Courier", 5))
        square.place(x = x, y = y)

    # create the add note window as it is unique to other windows
    def add_note(self, name, ws, wb):
        new_window = Toplevel()
        new_window.title("Add Note")
        new_window.geometry("300x110")

        note_label = Label(new_window, text = "Note:")
        note_label.config(font =("Courier", 15))
        note_label.place(x = 20, y = 10)

        note_entry = Entry(new_window, width = 42)
        note_entry.place(x = 20, y = 40)

        submit_button = Button(new_window, width = 10, bg='#e1e5eb', text='Save', command = lambda: self.save_note(note_entry.get(), name, ws, wb, new_window))
        submit_button.place(x = 197, y = 67)

        self.window.center(new_window)

    # save note to relevant row in calendar excel document
    def save_note(self, note, name, ws, wb, new_window):
        row = ws.max_row
        
        for i in range(1, row + 1):
            if ws.cell(column=2, row=i).value == name:
                ws.cell(column=4, row=i, value=note)
                break

        wb.save(PATH + '\\Data\\Original\\calendar.xlsx')

        new_window.destroy()
        # reopen calendar to update note
        self.cal_window.destroy()
        self.open_calendar()
        self.window.pop_up_window('Note saved successfully!', 'Confirmation')

    # display note for relevant order
    def view_note(self, name, ws):
        print(name)
        row = ws.max_row
        
        for i in range(1, row + 1):
            if ws.cell(column=2, row=i).value == name:
                note = ws.cell(column=4, row=i).value
                break
        
        if note is None:
            note = 'No note exists for this order.'

        window.pop_up_window(note, 'Note')

    # create edit contact window that allows for team members to be added/removed from orders
    def edit_contact(self, name, ws, wb, type):
        new_window = Toplevel()
        
        # alter the window based on whether the user is adding or removing a contact
        if type == 'add':
            new_window.title("Add Contact")
            contact_label = Label(new_window, text="Add Contact:", font=FONT)
            contact_label.place(x = 20, y = 10)
        else:
            new_window.title("Remove Contact")
            contact_label = Label(new_window, text="Remove Contact:", font=FONT)
            contact_label.place(x = 20, y = 10)

        new_window.geometry("280x90")

        # create drop down menu for team members
        menu = StringVar(new_window)
        menu.set('Vanessa')

        drop_down = OptionMenu(new_window, menu, 'Vanessa', 'Kurt', 'Di', 'Sophie', 'Workshop', 'Service', 'Other')
        drop_down.configure(bg='#e1e5eb')
        drop_down.place(x = 20, y = 45)

        if type == 'add':
            submit_button = Button(new_window, width = 10, bg='#e1e5eb', text='Submit', command = lambda: self.save_contact(new_window, name, menu.get(), ws, wb))
            submit_button.place(x = 177, y = 45)
        else:
            submit_button = Button(new_window, width = 10, bg='#e1e5eb', text='Submit', command = lambda: self.remove_contact(new_window, name, menu.get(), ws, wb))
            submit_button.place(x = 177, y = 45)

        self.window.center(new_window)
        
    # find the relevant customer and remove the team member from the order
    def remove_contact(self, new_window, name, contact, ws, wb):
        row = ws.max_row
        lowered = contact.lower()
        
        # loop through names until customer found, check team member cells and set them to ' ' if they match the contact to be removed
        for i in range(1, row + 1):
            if ws.cell(column=2, row=i).value == name:
                if ws.cell(column=5, row=i).value == lowered:
                    self.edit_excel_contact(ws, wb, 5, i, ' ', new_window)
                    return
                elif ws.cell(column=6, row=i).value == lowered:
                    self.edit_excel_contact(ws, wb, 6, i, ' ', new_window)
                    return
                elif ws.cell(column=7, row=i).value == lowered:
                    self.edit_excel_contact(ws, wb, 7, i, ' ', new_window)
                    return

    # edit the relevant cell in the excel document and save it
    def edit_excel_contact(self, ws, wb, col, row, value, new_window):
        if value == ' ':
            ws.cell(column=col, row=row, value=' ')
        else:
            ws.cell(column=col, row=row, value=value)

        wb.save(PATH + '\\Data\\Original\\calendar.xlsx')
        new_window.destroy()
        # reopen calendar to update contact
        self.cal_window.destroy()
        self.open_calendar()
        self.window.pop_up_window('Team member edited successfully!', 'Confirmation')

    # find the relevant customer and add the team member to the order, if full then display error message
    def save_contact(self, new_window, name, contact, ws, wb):
        row = ws.max_row
        lowered = contact.lower()
        
        for i in range(1, row + 1):
            if ws.cell(column=2, row=i).value == name:
                if ws.cell(column=5, row=i).value == None or ws.cell(column=5, row=i).value == ' ':
                    self.edit_excel_contact(ws, wb, 5, i, lowered, new_window)
                    return
                elif ws.cell(column=6, row=i).value == None or ws.cell(column=6, row=i).value == ' ':
                    self.edit_excel_contact(ws, wb, 6, i, lowered, new_window)
                    return
                elif ws.cell(column=7, row=i).value == None or ws.cell(column=7, row=i).value == ' ':
                    self.edit_excel_contact(ws, wb, 7, i, lowered, new_window)
                    return
                else:
                    self.window.pop_up_window('This order already has three team members assigned!', 'Error')

    def save_to_calendar(self, date, search_name, name, contact):
        
        if not os.path.exists(PATH + '\\Data\\Original\\calendar.xlsx'):
            wb = Workbook()
            wb.save(PATH + '\\Data\\Original\\calendar.xlsx')
            wb.close()

        wb = load_workbook(PATH + '\\Data\\Original\\calendar.xlsx')
        ws = wb['Sheet']
        row = ws.max_row + 1
        
        ws.cell(column=1, row=row, value=date)
        ws.cell(column=2, row=row, value=search_name)
        ws.cell(column=3, row=row, value=name)
        ws.cell(column=5, row=row, value=contact)

        wb.save(PATH + '\\Data\\Original\\calendar.xlsx')
        wb.close()

        # remove the order from the calendar when complete
    def remove_order(self, window, name, ws, wb):
        newWindow = Toplevel()
        newWindow.title("Confirm Removal")
        newWindow.geometry("655x110")

        note_label = Label(newWindow, text = "Are you sure you want to remove this order from the calendar?")    
        note_label.config(font =("Courier", 12))
        note_label.place(x = 20, y = 10)

        submit_button = Button(newWindow, width = 10, bg='#e1e5eb', text='Confirm', command = lambda: confirmRemoval(newWindow, window, name, ws, wb))
        submit_button.place(x = 280, y = 67)

        center(newWindow)

    def confirmRemoval(newWindow, window, name, ws, wb):
        rows = ws.max_row
        
        for i in range(1, rows + 1):
            if ws.cell(column=2, row=i).value == name:
                ws.delete_rows(i, 1)
                wb.save(PATH + '\\Data\\Original\\calendar.xlsx')
                break

        newWindow.destroy()
        window.destroy()
        openCalendar()

    '''
    def calenderPopUp(self):
        newWindow = Toplevel()
        newWindow.title("Added to Calendar")
        newWindow.geometry("350x100")

        note_label = Label(newWindow, text = 'Successfully added to calendar!')
        note_label.config(font =("Courier", 12))
        note_label.place(x = 20, y = 10)

        close_button = Button(newWindow, width = 10, bg='#e1e5eb', text='Ok', command = lambda: newWindow.destroy())
        close_button.place(x = 130, y = 57)

        self.window.center(newWindow)


    def upcomingDates():
        window = Toplevel()
        window.title("Upcoming Jobs")
        window.geometry("595x300")
        window.attributes('-topmost', 'true')
        
        # add a scrollbar to the window
        main_frame = Frame(window, width=595, height=300)
        main_frame.place(x=0,y=0)

        my_canvas = Canvas(main_frame, width=595, height=300)
        my_canvas.place(x=0,y=0)
        

        my_scrollbar = ttk.Scrollbar(main_frame, orient=VERTICAL, command=my_canvas.yview)
        my_scrollbar.place(x=575, y=0, height=300)

        my_canvas.configure(yscrollcommand=my_scrollbar.set)
        my_canvas.bind('<Configure>', lambda e: my_canvas.configure(scrollregion = my_canvas.bbox("all")))
        
        def _on_mouse_wheel(event):
            my_canvas.yview_scroll(-1 * int((event.delta / 120)), "units")
        
        my_canvas.bind_all("<MouseWheel>", _on_mouse_wheel)
        
        second_frame = Frame(my_canvas,width=595,height=100)
        second_frame.place(x=0,y=0) 
        
        my_canvas.create_window((0,0), window=second_frame, anchor="nw")   
        
        if not os.path.exists(PATH + '\\Data\\Original\\calendar.xlsx'):
            wb = Workbook()
            wb.save(PATH + '\\Data\\Original\\calendar.xlsx')
            wb.close()

        heading1 = Label(window, text = "Required in 1 day:")    
        heading1.config(font =("Courier", 15))
        heading1.place(x = 20, y = 10)

        heading7 = Label(window, text = "Required in 7 days:")
        heading7.config(font =("Courier", 15))
        heading7.place(x = 310, y = 10)
        
        # get relevant information from excel file
        wb = load_workbook(PATH + '\\Data\\Original\\calendar.xlsx')
        ws = wb['Sheet']
        rows = ws.max_row

        offset1 = 0
        offset7 = 0
        day = date.today()
        today = day.strftime("%d/%m/%Y")
        
        for i in range(1, rows + 1):
            try:
                req_date = cleanDate(ws.cell(column=1, row=i).value)
                req_date2 = readableDate(req_date)
                req_done = datetime.strptime(req_date2, "%d/%m/%Y")
                day = datetime.strptime(today, "%d/%m/%Y")

                diff = (req_done - day).days

                if diff == 1:
                    offset1 += 26
                    addJob(window, ws, i, offset1, 20)
                elif diff == 7:
                    offset7 += 26
                    addJob(window, ws, i, offset7, 310)
            except:
                pass

        window.configure(height=100 + max(offset1, offset7))
        center(window)

    def addJob(window, ws, i, offset, x):
        name = ws.cell(column=3, row=i).value
        search_name = ws.cell(column=2, row=i).value

        order_button = Button(window, width = 33, bg='#e1e5eb', text=name, command = lambda i=i: open_doc(search_name, name))
        order_button.place(x = x, y = 20 + offset)
        '''

# class that generates fields for different job sheets
class JobSheets:
    def __init__(self, frame, master):
        # initialize all the variables to be stored in the database
        self.frame = frame
        self.master = master
        self.double11 = PhotoImage(file=PATH + '\\Resources\\Images\\double_11.png')
        self.double40 = PhotoImage(file=PATH + '\\Resources\\Images\\double_40.png')
        self.double4 = PhotoImage(file=PATH + '\\Resources\\Images\\double_4.png')
        self.double_big = PhotoImage(file=PATH + '\\Resources\\Images\\double_big.png')
        self.current_sheet = ''
        self.qty_entries = []
        self.num_entries = []
        self.sport_entries = []
        self.details_entries = []
        self.unit_entries = []
        self.total_entries = []
        
        # button that creates the trophy sheet entries/labels
        self.button_trophy = PhotoImage(file=PATH + '\\Resources\\Images\\trophy_sheet.png')
        self.trophy_button = Button(frame, image=self.button_trophy, command=self.trophy_sheet, border=0, bg='white', highlightthickness=0)
        self.trophy_button.grid(row=0, column=1, padx=(25,0), pady=(150, 0), sticky=NW)

        # button that creates the engraving sheet entries/labels
        self.button_engraving = PhotoImage(file=PATH + '\\Resources\\Images\\engraving_sheet.png')
        self.engraving_button = Button(frame, image=self.button_engraving, command=self.engraving_sheet, border=0, bg='white', highlightthickness=0)
        self.engraving_button.grid(row=0, column=1, padx=(179,0), pady=(150, 0), sticky=NW)
    
    # delete relevant info from previous job sheet
    def delete_info(self):
        # clear all the entries
        self.qty_entries = []
        self.num_entries = []
        self.sport_entries = []
        self.details_entries = []
        self.unit_entries = []
        self.total_entries = []
        
        if self.current_sheet == 'trophy':    
            self.qty_label.destroy()
            self.trophy_num.destroy()
            self.trophy_sport.destroy()
            self.engrave_details.destroy()
            self.unit_price.destroy()
            self.total.destroy()
        elif self.current_sheet == 'engraving':
            self.qty_label.destroy()
            self.engrave_details.destroy()
        else:
            pass
            
    # implement scrollbar for the job sheet
    def scrollbar(self):        
        width = 845
        height = 230
        
        self.scroll_frame = Frame(self.frame, width=width, height=height)
        self.scroll_frame.place(x=370,y=350)

        self.my_canvas = Canvas(self.scroll_frame, width=width, height=height, bg='white', highlightthickness=0)
        self.my_canvas.place(x=0,y=0)
        
        self.my_scrollbar = ttk.Scrollbar(self.scroll_frame, orient=VERTICAL, command=self.my_canvas.yview)
        self.my_scrollbar.place(x=width-20, y=0, height=height)

        self.my_canvas.configure(yscrollcommand=self.my_scrollbar.set)
        self.my_canvas.bind('<Configure>', lambda e: self.my_canvas.configure(scrollregion = self.my_canvas.bbox("all")))
        
        def _on_mouse_wheel(event):
            self.my_canvas.yview_scroll(-1 * int((event.delta / 120)), "units")
        
        self.my_canvas.bind_all("<MouseWheel>", _on_mouse_wheel)
        
        self.second_frame = Frame(self.my_canvas,width=width,height=62, bg='white', highlightthickness=0)
        self.second_frame.place(x=0,y=0)

        self.my_canvas.create_window((0,0), window=self.second_frame, anchor="nw")

    # function that creates entry fields for extra info such as order numner, date, etc.
    def order_info(self):
        self.date = Label(self.frame, text='Date', font=FONT, bg='white')
        self.date.grid(row=0, column=1, padx=(18,0), pady=(200, 0), sticky=NW)
        self.image15 = PhotoImage(file=PATH + '\\Resources\\Images\\entry_15.png')
        self.date_label = Label(self.frame, image=self.image15, border=0)
        self.date_label.grid(row=0, column=1, padx=18, pady=(220, 0), sticky=NW)
        self.date_entry = Entry(self.frame, width=15, border=0, font=FONT, fg=ENTRY_COLOUR)
        self.date_entry.grid(row=0, column=1, padx=(23,0), pady=(225, 0), sticky=NW)

        # auto enter todays date
        today = date.today()
        d1 = today.strftime("%d/%m/%Y")
        self.date_entry.insert(0, d1)

        self.req = Label(self.frame, text='Required Date', font=FONT, bg='white')
        self.req.grid(row=0, column=1, padx=(185,0), pady=(200, 0), sticky=NW)
        self.req_label = Label(self.frame, image=self.image15, border=0)
        self.req_label.grid(row=0, column=1, padx=(185,0), pady=(220, 0), sticky=NW)
        self.req_entry = Entry(self.frame, width=15, border=0, font=FONT, fg=ENTRY_COLOUR)
        self.req_entry.grid(row=0, column=1, padx=(190,0), pady=(225, 0), sticky=NW)

        self.contact = Label(self.frame, text='Contact', font=FONT, bg='white')
        self.contact.grid(row=0, column=1, padx=(352,0), pady=(200, 0), sticky=NW)
        self.contact_label = Label(self.frame, image=self.image15, border=0)
        self.contact_label.grid(row=0, column=1, padx=(352,0), pady=(220, 0), sticky=NW)
        self.contact_entry = Entry(self.frame, width=15, border=0, font=FONT, fg=ENTRY_COLOUR)
        self.contact_entry.grid(row=0, column=1, padx=(357,0), pady=(225, 0), sticky=NW)

        self.order = Label(self.frame, text='Order Number', font=FONT, bg='white')
        self.order.grid(row=0, column=1, padx=(18,0), pady=(254, 0), sticky=NW)
        self.order_label = Label(self.frame, image=self.image15, border=0)
        self.order_label.grid(row=0, column=1, padx=18, pady=(274, 0), sticky=NW)
        self.order_entry = Entry(self.frame, width=15, border=0, font=FONT, fg=ENTRY_COLOUR)
        self.order_entry.grid(row=0, column=1, padx=(23,0), pady=(279, 0), sticky=NW)

        self.invoice = Label(self.frame, text='Invoice Number', font=FONT, bg='white')
        self.invoice.grid(row=0, column=1, padx=(185,0), pady=(254, 0), sticky=NW)
        self.invoice_label = Label(self.frame, image=self.image15, border=0)
        self.invoice_label.grid(row=0, column=1, padx=(185,0), pady=(274, 0), sticky=NW)
        self.invoice_entry = Entry(self.frame, width=15, border=0, font=FONT, fg=ENTRY_COLOUR)
        self.invoice_entry.grid(row=0, column=1, padx=(190,0), pady=(279, 0), sticky=NW)

        self.team = Label(self.frame, text='Team Member', font=FONT, bg='white')
        self.team.grid(row=0, column=1, padx=(352,0), pady=(254, 0), sticky=NW)
        self.team_label = Label(self.frame, image=self.image15, border=0)
        self.team_label.grid(row=0, column=1, padx=(352,0), pady=(274, 0), sticky=NW)
        self.team_entry = Entry(self.frame, width=15, border=0, font=FONT, fg=ENTRY_COLOUR)
        self.team_entry.grid(row=0, column=1, padx=(357,0), pady=(279, 0), sticky=NW)

        self.overall = Label(self.frame, text='Overall Price', font='GoogleSans 12 bold', bg='white', fg='#858585')
        self.overall.grid(row=0, column=1, padx=(18,0), pady=(600, 0), sticky=NW)
        self.overall_label = Label(self.frame, image=self.image15, border=0)
        self.overall_label.grid(row=0, column=1, padx=(125,0), pady=(597, 0), sticky=NW)
        self.overall_entry = Entry(self.frame, width=15, border=0, font=FONT, fg=ENTRY_COLOUR)
        self.overall_entry.grid(row=0, column=1, padx=(130,0), pady=(602, 0), sticky=NW)
    
    # create engraving sdheet entries/label and call scrollbar/row creation functions
    def engraving_sheet(self):
        # only create order info if it hasn't been created yet
        if self.current_sheet == '':
            self.order_info()
        
        # delete table headings if they exist (different headings between trophy and engraving)
        self.delete_info()
        self.current_sheet = 'engraving'

        self.qty_label = Label(self.frame, text='Qty', font='GoogleSans 12 bold', bg='white', fg='#858585')
        self.qty_label.grid(row=0, column=1, padx=(17,0), pady=(327, 0), sticky=NW)

        self.engrave_details = Label(self.frame, text='Engraving Details', font='GoogleSans 12 bold', bg='white', fg='#858585')
        self.engrave_details.grid(row=0, column=1, padx=(67,0), pady=(327, 0), sticky=NW)

        self.scrollbar()
        self.add_rows_engraving()
    
    # create trophy sheet entries/label and call scrollbar/row creation functions
    def trophy_sheet(self):
        # only create order info if it hasn't been created yet
        if self.current_sheet == '':
            self.order_info()

        # delete table headings if they exist (different headings between trophy and engraving)
        self.delete_info()
        self.current_sheet = 'trophy'

        # all trophy sheet headings
        self.qty_label = Label(self.frame, text='Qty', font='GoogleSans 12 bold', bg='white', fg='#858585')
        self.qty_label.grid(row=0, column=1, padx=(17,0), pady=(327, 0), sticky=NW)

        self.trophy_num = Label(self.frame, text='Trophy #', font='GoogleSans 12 bold', bg='white', fg='#858585')
        self.trophy_num.grid(row=0, column=1, padx=(67,0), pady=(327, 0), sticky=NW)

        self.trophy_sport = Label(self.frame, text='Sport', font='GoogleSans 12 bold', bg='white', fg='#858585')
        self.trophy_sport.grid(row=0, column=1, padx=(173,0), pady=(327, 0), sticky=NW)

        self.engrave_details = Label(self.frame, text='Engraving Details', font='GoogleSans 12 bold', bg='white', fg='#858585')
        self.engrave_details.grid(row=0, column=1, padx=(279,0), pady=(327, 0), sticky=NW)

        self.unit_price = Label(self.frame, text='Unit Price', font='GoogleSans 12 bold', bg='white', fg='#858585')
        self.unit_price.grid(row=0, column=1, padx=(620,0), pady=(327, 0), sticky=NW)

        self.total = Label(self.frame, text='Total', font='GoogleSans 12 bold', bg='white', fg='#858585')
        self.total.grid(row=0, column=1, padx=(724,0), pady=(327, 0), sticky=NW)

        self.scrollbar()
        self.add_rows_trophy()
                
    # add entry rows for the trophy job sheet
    def add_rows_trophy(self):
        self.second_frame.configure(height=62)
        for i in range(20):
            qty = Label(self.second_frame, image=self.double4, border=0)            
            qty.grid(row=i, column=0, padx=(5,0), pady=(0,0), sticky=NW)
            self.qty_entries.append(Text(self.second_frame, width=4, height=2, border=0, font=FONT, fg=ENTRY_COLOUR))
            self.qty_entries[i].grid(row=i, column=0, padx=(9,0), pady=(4,5), rowspan=1, sticky=NW)

            num = Label(self.second_frame, image=self.double11, border=0)            
            num.grid(row=i, column=1, padx=(5,0), pady=(0,0), sticky=NW)
            self.num_entries.append(Text(self.second_frame, width=11, height=2, border=0, font=FONT, fg=ENTRY_COLOUR))
            self.num_entries[i].grid(row=i, column=1, padx=(10,0), pady=(5,5), rowspan=1, sticky=NW)

            sport = Label(self.second_frame, image=self.double11, border=0) 
            sport.grid(row=i, column=2, padx=(5,0), pady=(0,0), sticky=NW)
            self.sport_entries.append(Text(self.second_frame, width=11, height=2, border=0, font=FONT, fg=ENTRY_COLOUR))
            self.sport_entries[i].grid(row=i, column=2, padx=(10,0), pady=(5,5), rowspan=1, sticky=NW)

            details = Label(self.second_frame, image=self.double40, border=0) 
            details.grid(row=i, column=3, padx=(5,0), pady=(0,0), sticky=NW)
            self.details_entries.append(Text(self.second_frame, width=40, height=2, border=0, font=FONT, fg=ENTRY_COLOUR))
            self.details_entries[i].grid(row=i, column=3, padx=(10,0), pady=(4,5), rowspan=1, sticky=NW)

            unit = Label(self.second_frame, image=self.double11, border=0) 
            unit.grid(row=i, column=4, padx=(5,0), pady=(0,0), sticky=NW)
            self.unit_entries.append(Text(self.second_frame, width=11, height=2, border=0, font=FONT, fg=ENTRY_COLOUR))
            self.unit_entries[i].grid(row=i, column=4, padx=(10,0), pady=(5,5), rowspan=1, sticky=NW)

            total = Label(self.second_frame, image=self.double11, border=0) 
            total.grid(row=i, column=5, padx=(5,0), pady=(0,0), sticky=NW)
            self.total_entries.append(Text(self.second_frame, width=11, height=2, border=0, font=FONT, fg=ENTRY_COLOUR))
            self.total_entries[i].grid(row=i, column=5, padx=(10,5), pady=(5,5), rowspan=1, sticky=NW)
        
            # adjust height of scrollbar frame
            self.second_frame.configure(height=62 + (i * 46))

    # add entry rows for engraving job sheet
    def add_rows_engraving(self):
        self.second_frame.configure(height=62)
        for i in range(20):
            qty = Label(self.second_frame, image=self.double4, border=0)            
            qty.grid(row=i, column=0, padx=(5,0), pady=(0,0), sticky=NW)
            self.qty_entries.append(Text(self.second_frame, width=4, height=2, border=0, font=FONT, fg=ENTRY_COLOUR))
            self.qty_entries[i].grid(row=i, column=0, padx=(9,0), pady=(4,5), rowspan=1, sticky=NW)

            details = Label(self.second_frame, image=self.double_big, border=0) 
            details.grid(row=i, column=1, padx=(5,0), pady=(0,0), sticky=NW)
            self.details_entries.append(Text(self.second_frame, width=88, height=2, border=0, font=FONT, fg=ENTRY_COLOUR))
            self.details_entries[i].grid(row=i, column=1, padx=(10,0), pady=(5,5), rowspan=1, sticky=NW)

            # adjust height of scrollbar frame
            self.second_frame.configure(height=62 + (i * 46))

    # clear all entry fields in the job sheet
    def clear_entries(self):
        if self.current_sheet == '':
            pass
        else:
            # clear info fields
            self.req_entry.delete(0, END)
            self.contact_entry.delete(0, END)
            self.order_entry.delete(0, END)
            self.invoice_entry.delete(0, END)
            self.team_entry.delete(0, END)
            self.overall_entry.delete(0, END)

            # clear all entry fields
            for i in range(20):              
                self.qty_entries[i].delete(1.0, END)
                self.details_entries[i].delete(1.0, END)
                
                if self.current_sheet == 'trophy':
                    self.num_entries[i].delete(1.0, END)
                    self.sport_entries[i].delete(1.0, END)
                    self.unit_entries[i].delete(1.0, END)
                    self.total_entries[i].delete(1.0, END)


# class that handles all signature field functionality
class Signature:
    def __init__(self, frame):
        # impletement signature field
        self.signature(frame)

        # signature heading
        self.sig_label = Label(frame, text='Signature', font='GoogleSans 12 bold', bg='white', fg='#858585')
        self.sig_label.grid(row=0, column=1, padx=(553,0), pady=(5, 0), sticky=NW)
        
        # save a copy of the signature to the resources folder
        self.confirm_image = PhotoImage(file=PATH + '\\Resources\\Images\\confirm_sig.png')
        self.confirm_button = Button(frame ,image=self.confirm_image, command=lambda:(self.img.save(PATH + '\\Resources\\signature.png')), border=0, bg='white', highlightthickness=0)
        self.confirm_button.grid(row=0, column=1, padx=(720,20), pady=(165, 0), sticky=NW)

        self.clear_image = PhotoImage(file=PATH + '\\Resources\\Images\\clear_sig.png')
        self.clear_sig = Button(frame ,image=self.clear_image, command=self.clear_signature, border=0, bg='white', highlightthickness=0)
        self.clear_sig.grid(row=0, column=1, padx=(570,20), pady=(165, 0), sticky=NW)
        
    # clear signature field
    def clear_signature(self):
        self.w.delete('all')
        self.img = Image.new('RGB',(285,105), (255, 255, 255))
        self.draw = ImageDraw.Draw(self.img)

    
    # create signature field and implement functionality
    def signature(self, frame):    
        # image to make signature field look nice
        self.sig_field_image = PhotoImage(file=PATH + '\\Resources\\Images\\signature_field.png')
        self.sig_field_label = Label(frame, image=self.sig_field_image, border=0)
        self.sig_field_label.grid(row=0, column=1, padx=(550,20), pady=(31, 0), rowspan=2, sticky=NW)
        
        # actual signature field that is written on
        self.w = Canvas(frame, bg = 'white', highlightthickness=0, width=285, height = 105, name='signature field')
        self.w.grid(row=0, column=1, padx=(558,20), pady=(41, 0), rowspan=2, sticky=NW)
        self.img = Image.new('RGB',(285,105), (255, 255, 255))
        self.draw = ImageDraw.Draw(self.img)

        self.mousePressed = False
        self.last=None

        # mouse events
        def press(evt):
            self.mousePressed = True
        def release(evt):
            self.mousePressed = False

        self.w.bind_all('<ButtonPress-1>', press)
        self.w.bind_all('<ButtonRelease-1>', release)
            
        def move(evt):
            # get the position of the mouse
            x,y = frame.winfo_pointerxy()
            widget = frame.winfo_containing(x,y)
            # check if the mouse is in the signature field
            if str(widget) == '.!frame.signature field':
                # track mouse events to get customer signature
                x,y = evt.x,evt.y
                try:
                    if self.mousePressed:
                        if self.last is None:
                            self.last = (x,y)
                            return
                        self.draw.line(((x,y),self.last), (0,0,0))
                        self.w.create_line(x,y,self.last[0],self.last[1])
                        self.last = (x,y)
                    else:
                        self.last = (x,y)
                except:
                    pass

        self.w.bind_all('<Motion>', move)


# class that handles display and saving of previous customer orders, including autofill
class CustomerHistory:
    def __init__(self, frame, word_doc):
        self.word_doc = word_doc
        self.frame = frame
        self.cus_labels = []
        self.cus_sheets = []
        self.cus_autofill = []
        self.cus_calendar = []
        self.sheet_image = PhotoImage(file=PATH + '\\Resources\\Images\\cus_sheet.png')
        self.autofill_image = PhotoImage(file=PATH + '\\Resources\\Images\\cus_autofill.png')
        self.calendar_image = PhotoImage(file=PATH + '\\Resources\\Images\\cus_calendar.png')
        
        self.history = Label(frame, text='Previous Orders', font='GoogleSans 12 bold', bg='white', fg='#858585')
        self.history.grid(row=0, column=0, padx=20, pady=(485, 0), sticky=NW)

    # display names along with buttons to open, autofill and save to calendar
    def show_history(self, name):
        self.clear_history()
        self.name = name
        self.cus_labels = []
        self.cus_sheets = []
        self.cus_autofill = []
        self.cus_calendar = []
        # get customer history
        self.get_history()
        self.display_name()

        # display unique customer names with buttons
        for i in range(len(self.cus_history_fixed)):
            self.cus_labels.append(Label(self.frame, text=self.cus_history_fixed[i], border=0, font=FONT, width=16, bg='white'))
            self.cus_labels[i].grid(row=0, column=0, padx=(20,0), pady=(512 + (i * 25), 0), sticky=NW)

            # button to open specified sheet
            self.cus_sheets.append(Button(self.frame, image=self.sheet_image, border=0, bg='white', highlightthickness=0, command=lambda i=i:self.word_doc.open_doc(self.cus_history[i], self.name)))
            self.cus_sheets[i].grid(row=0, column=0, padx=(175,0), pady=(512 + (i * 25), 0), sticky=NW)

            # button to autofill data from specified sheet
            self.cus_autofill.append(Button(self.frame, image=self.autofill_image, border=0, bg='white', highlightthickness=0, command=lambda i=i:self.word_doc.autofill(self.cus_history[i], self.name)))
            self.cus_autofill[i].grid(row=0, column=0, padx=(230,0), pady=(512 + (i * 25), 0), sticky=NW)

            # button to add order to calendar
            self.cus_calendar.append(Button(self.frame, image=self.calendar_image, border=0, bg='white', highlightthickness=0, command=lambda:print('calendar')))
            self.cus_calendar[i].grid(row=0, column=0, padx=(285,0), pady=(512 + (i * 25), 0), sticky=NW)

    # remove previous customer history
    def clear_history(self):
        for i in range(len(self.cus_labels)):
            self.cus_labels[i].destroy()
            self.cus_sheets[i].destroy()
            self.cus_autofill[i].destroy()
            self.cus_calendar[i].destroy()

    # alter the customer name for display purposes
    def display_name(self):
        self.cus_history_fixed = []
        for i in range(len(self.cus_history)):
            sheet = self.cus_history[i][:1]
            day = self.cus_history[i][1:3]
            month = self.cus_history[i][4:6]
            year = self.cus_history[i][9:11]

            self.cus_history_fixed.append(sheet + ' ' + day + '/' + month + '/' + year + ' ' + self.cus_history[i][12:22])
    
    # get the unique names of the last 5 orders if they exist
    def get_history(self):
        self.cus_history = []
        # create a customer autofill excel doc if one doesn't exist
        if os.path.exists(PATH + '\\Data\\Autofill\\' + self.name + '\\autofill_data.xlsx'):    
            auto_f = load_workbook(PATH + '\\Data\\Autofill\\' + self.name + '\\autofill_data.xlsx')
        else:
            source = PATH + '\\Data\\Original\\autofill_data.xlsx'
            destination = PATH + '\\Data\\Autofill\\' + self.name
            os.makedirs(destination)
            shutil.copy(source, destination)
            auto_f = load_workbook(PATH + '\\Data\\Autofill\\' + self.name + '\\autofill_data.xlsx')
        
        auto_sheet = auto_f['Sheet1']
        last_row = auto_sheet.max_row

        # get the unique names of the last 5 orders if they exist
        for i in range(5):
            current_row = last_row - i
            if current_row <= 2:
                pass
            else:
                self.cus_history.append(auto_sheet.cell(row=current_row, column=1).value)
        
        # save and close the file
        auto_f.save(PATH + '\\Data\\Autofill\\' + self.name + '\\autofill_data.xlsx')
        auto_f.close()
        

# class that handles searching customers by name, retrieving information, creating new customers, deleting customers, and updating customer information
class CustomerDetails:
    def __init__(self, frame, window, customer_history, sheet):
        # load all customer names from excel doc
        self.sheet = sheet
        self.cus_names = []
        self.customer_history = customer_history
        try:
            wb = load_workbook(PATH + '\\Data\\Customer List\\GTC Customer List.xlsx')
            ws = wb['Sheet1']  
            name = ws['A']
            self.cus_names = [name[x].value for x in range(len(name))]
            del self.cus_names[0]
            wb.close()
        except:
            window.pop_up_window('Error! Customer List Not Found', 'Error')
        
        # create label for search entry
        self.search_image = PhotoImage(file=PATH + '\\Resources\\Images\\search_box.png')
        self.search_label = Label(frame, image=self.search_image, border=0)
        self.search_label.grid(row=0, column=0, padx=15, pady=(5, 0), sticky=NW)
        
        # create search entry field that can be submitted by pressing enter
        self.search_entry = Entry(frame)
        self.search_entry.configure(width=32, foreground='grey', font=FONT, border=0)
        self.search_entry.insert(END, 'Search for a Customer')
        self.search_entry.bind('<KeyRelease>', self.check_listbox)
        self.search_entry.bind('<1>', self.clicked)
        self.search_entry.grid(row=0, column=0, padx=50, pady=(12, 0), sticky=NW)

        # create list box to fill with autocomplete suggestions
        self.listbox = Listbox(frame, exportselection=False, border=0, width=32, height=5, font=FONT, fg='grey', highlightthickness=0)
        self.listbox.grid(row=0, column=0, padx=48, pady=(40,0), sticky=NW)
        self.listbox.bind('<<ListboxSelect>>', self.autofill)

        # add button to clear search entry
        self.clear_button = Button(frame, text='x', command=lambda:(self.search_entry.delete(0, END), self.update_listbox([])), border=0, bg='white', fg='grey', font=FONT, highlightthickness=0)
        self.clear_button.grid(row=0, column=0, padx=(291, 0), pady=(10, 2), sticky=NW)

        # create all entry fields with labels, cumbersome/lengthy code so moved out of __init__
        self.create_entries(frame)

        # create button to clear all entry fields
        self.cus_clear = PhotoImage(file=PATH + '\\Resources\\Images\\cus_clear.png')
        self.clear_button = Button(frame, image=self.cus_clear, command=self.clear_cus_entries, border=0, bg='white', highlightthickness=0)
        self.clear_button.grid(row=0, column=0, padx=(30, 0), pady=(413, 8), sticky=NW)

        # create button to add new customer to database
        self.cus_add = PhotoImage(file=PATH + '\\Resources\\Images\\add_customer.png')
        self.add_button = Button(frame, image=self.cus_add, command=self.add_customer, border=0, bg='white', highlightthickness=0)
        self.add_button.grid(row=0, column=0, padx=(182, 0), pady=(413, 8), sticky=NW)

        # create button to edit customer information in database
        self.cus_edit = PhotoImage(file=PATH + '\\Resources\\Images\\edit_customer.png')
        self.edit_button = Button(frame, image=self.cus_edit, command=self.edit_customer, border=0, bg='white', highlightthickness=0)
        self.edit_button.grid(row=0, column=0, padx=(30, 0), pady=(447, 5), sticky=NW)

        # create button to edit customer information in database
        self.cus_del = PhotoImage(file=PATH + '\\Resources\\Images\\delete_customer.png')
        self.del_button = Button(frame, image=self.cus_del, command=self.delete_customer, border=0, bg='white', highlightthickness=0)
        self.del_button.grid(row=0, column=0, padx=(182, 0), pady=(447, 5), sticky=NW)

        # button to save new sheet
        self.button_save = PhotoImage(file=PATH + '\\Resources\\Images\\button_save.png')
        self.save_button = Button(frame, image=self.button_save, command=lambda:self.sheet.create_doc(self.name_entry.get(), self.address_entry.get(), self.state_entry.get(), 
                           self.city_entry.get(), self.postcode_entry.get(), self.phone_entry.get(), self.email_entry.get()), border=0, bg='white', highlightthickness=0)
        self.save_button.grid(row=0, column=1, padx=(725,0), pady=(595, 0), sticky=NW)

    # checks if customer is in list and confirms edit
    def edit_customer(self):
        name = self.name_entry.get()
        if name not in self.cus_names:
            window.pop_up_window('Error! Customer does not exist', 'Error')
        else:
            window.option_message(f'Are you sure you want to change {name} information to the entered details?', 'edit')

    # get the row of the customer in the excel doc and change the values to the new values
    def edit_cus(self):
        name = self.name_entry.get()
        try:
            row = self.cus_names.index(name) + 2

            wb = load_workbook(PATH + '\\Data\\Customer List\\GTC Customer List.xlsx')
            ws = wb['Sheet1']

            ws.cell(column=1, row=row, value=self.name_entry.get())
            ws.cell(column=3, row=row, value=self.address_entry.get())
            ws.cell(column=5, row=row, value=self.state_entry.get())
            ws.cell(column=4, row=row, value=self.city_entry.get())
            ws.cell(column=6, row=row, value=self.postcode_entry.get())
            ws.cell(column=7, row=row, value=self.phone_entry.get())
            ws.cell(column=8, row=row, value=self.email_entry.get())

            wb.save(PATH + '\\Data\\Customer List\\GTC Customer List.xlsx')
            wb.close()
            window.pop_up_window(f'{name} Information Updated', 'Confirmation')
            self.clear_cus_entries()
        except:
            window.pop_up_window('Error! Customer List Not Found', 'Error')

    # creates the message and opens option window
    def delete_customer(self):
        name = self.name_entry.get()
        if name not in self.cus_names:
            window.pop_up_window('Error! Customer does not exist', 'Error')
        else:
            window.option_message(f'Are you sure you want to delete {name} from the customer list?', 'delete')

    # deletes the customer from the excel doc
    def del_cus(self):
        name = self.name_entry.get()
        try:
            row = self.cus_names.index(name) + 2

            wb = load_workbook(PATH + '\\Data\\Customer List\\GTC Customer List.xlsx')
            ws = wb['Sheet1']
            ws.delete_rows(row, 1)

            wb.save(PATH + '\\Data\\Customer List\\GTC Customer List.xlsx')
            wb.close()

            self.cus_names.remove(name)

            window.pop_up_window(f'Successfully deleted {name} from the customer list', 'Confirmation')
        except:
            window.pop_up_window('Error! Customer List Not Found', 'Error')

    # add customer to the excel doc and update the list of customer names
    def add_customer(self):
        # check if customer name already exists
        if self.name_entry.get() in self.cus_names:
            window.pop_up_window('Error! Customer already exists', 'Error')
        elif self.name_entry.get() == '':
            window.pop_up_window('Error! Name field cannot be empty', 'Error')
        else:
            try:
                name = self.name_entry.get()
                
                # add new customer to excel doc
                wb = load_workbook(PATH + '\\Data\\Customer List\\GTC Customer List.xlsx')
                ws = wb['Sheet1'] 
                max_row = ws.max_row + 1

                ws.cell(column=1, row=max_row, value=self.name_entry.get())
                ws.cell(column=3, row=max_row, value=self.address_entry.get())
                ws.cell(column=5, row=max_row, value=self.state_entry.get())
                ws.cell(column=4, row=max_row, value=self.city_entry.get())
                ws.cell(column=6, row=max_row, value=self.postcode_entry.get())
                ws.cell(column=7, row=max_row, value=self.phone_entry.get())
                ws.cell(column=8, row=max_row, value=self.email_entry.get())

                wb.save(PATH + '\\Data\\Customer List\\GTC Customer List.xlsx')
                wb.close()

                self.cus_names.append(name)

                window.pop_up_window(f'Successfully added {name} to the customer list', 'Confirmation')
            except:
                window.pop_up_window('Error! Customer List Not Found', 'Error')
    
    # clears all entry fields for customer data
    def clear_cus_entries(self):
        self.name_entry.delete(0, END)
        self.address_entry.delete(0, END)
        self.state_entry.delete(0, END)
        self.city_entry.delete(0, END)
        self.postcode_entry.delete(0, END)
        self.phone_entry.delete(0, END)
        self.email_entry.delete(0, END)
    
    # delete default search entry text when clicked
    def clicked(self, event=None):
        if self.search_entry.get() == 'Search for a Customer':
            self.search_entry.delete(0, END)
        
    # check if search entry matches any customer names and update listbox
    def check_listbox(self, event=None):
        typed = self.search_entry.get()
        self.search_entry.configure(foreground='black')

        if typed == '':
            data = []
        else:
            data = []
            for name in self.cus_names:
                if typed.lower() in name.lower():
                    data.append(name)
        
        self.update_listbox(data)
    
    # update suggestions based on search entry
    def update_listbox(self, data):
        self.listbox.delete(0, END)
        for name in data:
            self.listbox.insert(END, name)

    # autofill entry and customer information based on selection
    def autofill(self, event=None):
        try:
            self.search_entry.delete(0, END)
            self.search_entry.insert(0, self.listbox.get(self.listbox.curselection()))
            self.update_listbox([])
        except:
            self.search_entry.configure(foreground='grey')
            self.search_entry.insert(END, 'Search for a Customer')
        
        entry_name = self.search_entry.get()

        if entry_name != 'Search for a Customer':
            try:
                # autofill customer information
                self.clear_cus_entries()
                row = self.cus_names.index(entry_name) + 2

                wb = load_workbook(PATH + '\\Data\\Customer List\\GTC Customer List.xlsx')
                ws = wb['Sheet1']  
                # confirming there is a value in the cell, does not like empty cells
                if ws.cell(row=row, column=1).value:
                    self.name_entry.insert(0, ws.cell(row=row, column=1).value)
                if ws.cell(row=row, column=3).value:
                    self.address_entry.insert(0, ws.cell(row=row, column=3).value)
                if ws.cell(row=row, column=5).value:
                    self.state_entry.insert(0, ws.cell(row=row, column=5).value)
                if ws.cell(row=row, column=4).value:
                    self.city_entry.insert(0, ws.cell(row=row, column=4).value)
                if ws.cell(row=row, column=6).value:
                    self.postcode_entry.insert(0, ws.cell(row=row, column=6).value)
                if ws.cell(row=row, column=7).value:
                    self.phone_entry.insert(0, ws.cell(row=row, column=7).value)
                if ws.cell(row=row, column=8).value:
                    self.email_entry.insert(0, ws.cell(row=row, column=8).value)

                wb.close()
            except:
                window.pop_up_window('Error! Customer List Not Found', 'Error')

            # when name selected also display previous orders
            self.customer_history.show_history(entry_name)


    # creates all customer entry fields and labels
    def create_entries(self, frame):
        self.name_text = Label(frame, text='Customer Name', font=FONT, bg='white')
        self.name_text.grid(row=0, column=0, padx=20, pady=(136, 0), sticky=NW)
        self.image35 = PhotoImage(file=PATH + '\\Resources\\Images\\entry_36.png')
        self.name_label = Label(frame, image=self.image35, border=0)
        self.name_label.grid(row=0, column=0, padx=18, pady=(156,0), sticky=NW)
        self.name_entry = Entry(frame, width=36, border=0, font=FONT, fg=ENTRY_COLOUR)
        self.name_entry.grid(row=0, column=0, padx=(27,0), pady=(162,0), sticky=NW)

        self.address_text = Label(frame, text='Address', font=FONT, bg='white')
        self.address_text.grid(row=0, column=0, padx=20, pady=(190, 0), sticky=NW)
        self.address_label = Label(frame, image=self.image35, border=0)
        self.address_label.grid(row=0, column=0, padx=18, pady=(210,0), sticky=NW)
        self.address_entry = Entry(frame, width=36, border=0, font=FONT, fg=ENTRY_COLOUR)
        self.address_entry.grid(row=0, column=0, padx=(27,0), pady=(216,0), sticky=NW)

        self.state_text = Label(frame, text='State', font=FONT, bg='white')
        self.state_text.grid(row=0, column=0, padx=(229, 0), pady=(244, 0), sticky=NW)
        self.image10 = PhotoImage(file=PATH + '\\Resources\\Images\\entry_10.png')
        self.state_label = Label(frame, image=self.image10, border=0)
        self.state_label.grid(row=0, column=0, padx=(227, 0), pady=(264, 0), sticky=NW)
        self.state_entry = Entry(frame, width=10, border=0, font=FONT, fg=ENTRY_COLOUR)
        self.state_entry.grid(row=0, column=0, padx=(236,0), pady=(270, 0), sticky=NW)

        self.city_text = Label(frame, text='City', font=FONT, bg='white')
        self.city_text.grid(row=0, column=0, padx=20, pady=(244, 0), sticky=NW)
        self.image20 = PhotoImage(file=PATH + '\\Resources\\Images\\entry_20.png')
        self.city_label = Label(frame, image=self.image20, border=0)
        self.city_label.grid(row=0, column=0, padx=18, pady=(264, 0), sticky=NW)
        self.city_entry = Entry(frame, width=20, border=0, font=FONT, fg=ENTRY_COLOUR)
        self.city_entry.grid(row=0, column=0, padx=(27,0), pady=(270, 0), sticky=NW)

        self.postcode_text = Label(frame, text='Postcode', font=FONT, bg='white')
        self.postcode_text.grid(row=0, column=0, padx=(229, 0), pady=(298, 0), sticky=NW)
        self.postcode_label = Label(frame, image=self.image10, border=0)
        self.postcode_label.grid(row=0, column=0, padx=(227, 0), pady=(318, 0), sticky=NW)
        self.postcode_entry = Entry(frame, width=10, border=0, font=FONT, fg=ENTRY_COLOUR)
        self.postcode_entry.grid(row=0, column=0, padx=(236,0), pady=(324, 0), sticky=NW)

        self.phone_text = Label(frame, text='Phone Number', font=FONT, bg='white')
        self.phone_text.grid(row=0, column=0, padx=20, pady=(298, 0), sticky=NW)
        self.phone_label = Label(frame, image=self.image20, border=0)
        self.phone_label.grid(row=0, column=0, padx=18, pady=(318, 0), sticky=NW)
        self.phone_entry = Entry(frame, width=20, border=0, font=FONT, fg=ENTRY_COLOUR)
        self.phone_entry.grid(row=0, column=0, padx=(27,0), pady=(324, 0), sticky=NW)

        self.email_text = Label(frame, text='Email Address', font=FONT, bg='white')
        self.email_text.grid(row=0, column=0, padx=20, pady=(352,0), sticky=NW)
        self.email_label = Label(frame, image=self.image35, border=0)
        self.email_label.grid(row=0, column=0, padx=18, pady=(372,0), sticky=NW)
        self.email_entry = Entry(frame, width=36, border=0, font=FONT, fg=ENTRY_COLOUR)
        self.email_entry.grid(row=0, column=0, padx=(27,0), pady=(378,0), sticky=NW)

# class that generates a formatted word document from entered details
class WordDoc:
    def __init__(self, sheet):
        self.sheet = sheet
    
    # create the formatted word doc
    # code is quite long/cumbersome but functions properly
    def create_doc(self, name, address, state, city, postcode, phone, email):
        sheet_type = self.sheet.current_sheet
        
        # ensure a sheet is opened before saving
        if sheet_type == '':
            window.pop_up_window('Error! Please open a sheet before saving', 'Error')
        else:
            document = Document()
            
            #changing the page margins
            sections = document.sections
            for section in sections:
                section.top_margin = Cm(1)
                section.bottom_margin = Cm(1)
                section.left_margin = Cm(1)
                section.right_margin = Cm(1)
        
            # all word formatting, adding images, text, table etc
            document.add_picture(PATH + '\\Resources\\heading_image.png')
            
            paragraph1 = document.add_paragraph()
            paragraph1.alignment = 1
            paragraph1.paragraph_format.space_before = Pt(3)
            paragraph1.paragraph_format.space_after = Pt(1)
            a1 = paragraph1.add_run('Customer: ')
            font = a1.font
            font.size = Pt(14)
            a1.bold = True
            a2 = paragraph1.add_run(self.check_empty(name))
            font = a2.font
            font.size = Pt(14)
                            
            paragraph2 = document.add_paragraph()
            paragraph2.alignment = 1
            paragraph2.paragraph_format.space_before = Pt(1)
            paragraph2.paragraph_format.space_after = Pt(1)
            b1 = paragraph2.add_run('Address: ')
            font = b1.font
            font.size = Pt(14)
            b1.bold = True
            b2 = paragraph2.add_run(self.check_empty(address))
            font = b2.font
            font.size = Pt(14)

            paragraph3 = document.add_paragraph()
            paragraph3.alignment = 1
            paragraph3.paragraph_format.space_before = Pt(1)
            paragraph3.paragraph_format.space_after = Pt(1)
            c1 = paragraph3.add_run('State: ')
            font = c1.font
            font.size = Pt(14)
            c1.bold = True
            c2 = paragraph3.add_run(self.check_empty(state))
            font = c2.font
            font.size = Pt(14)
            c5 = paragraph3.add_run('       City: ')
            font = c5.font
            font.size = Pt(14)
            c5.bold = True
            c3 = paragraph3.add_run(self.check_empty(city))
            font = c3.font
            font.size = Pt(14)
            c6 = paragraph3.add_run('       Postcode: ')
            font = c6.font
            font.size = Pt(14)
            c6.bold = True
            c4 = paragraph3.add_run(self.check_empty(postcode))
            font = c4.font
            font.size = Pt(14)

            paragraph4 = document.add_paragraph()
            paragraph4.alignment = 1
            paragraph4.paragraph_format.space_before = Pt(1)
            paragraph4.paragraph_format.space_after = Pt(1)
            d1 = paragraph4.add_run('Phone: ')
            font = d1.font
            font.size = Pt(14)
            d1.bold = True
            d2 = paragraph4.add_run(self.check_empty(phone))
            font = d2.font
            font.size = Pt(14)
            d3 = paragraph4.add_run('       Email: ')
            font = d3.font
            font.size = Pt(14)
            d3.bold = True
            d4 = paragraph4.add_run(self.check_empty(email))
            font = d4.font
            font.size = Pt(14)

            paragraph5 = document.add_paragraph()
            paragraph5.alignment = 1
            paragraph5.paragraph_format.space_before = Pt(1)
            paragraph5.paragraph_format.space_after = Pt(1)
            e1 = paragraph5.add_run('Contact: ')
            font = e1.font
            font.size = Pt(14)
            e1.bold = True
            e2 = paragraph5.add_run(self.check_empty(self.sheet.contact_entry.get()))
            font = e2.font
            font.size = Pt(14)

            paragraph_space = document.add_paragraph()
            paragraph_space.alignment = 1
            paragraph_space.paragraph_format.space_before = Pt(1)
            paragraph_space.paragraph_format.space_after = Pt(1)
            y1 = paragraph_space.add_run(' ')
            font = y1.font
            font.size = Pt(14)

            paragraph6 = document.add_paragraph()
            paragraph6.alignment = 1
            paragraph6.paragraph_format.space_before = Pt(1)
            paragraph6.paragraph_format.space_after = Pt(1)
            f1 = paragraph6.add_run('    Date: ')
            font = f1.font
            font.size = Pt(14)
            f1.bold = True
            f2 = paragraph6.add_run(self.check_empty(self.sheet.date_entry.get()))
            font = f2.font
            font.size = Pt(14)
            f3 = paragraph6.add_run('    Invoice No: ')
            font = f3.font
            font.size = Pt(14)
            f3.bold = True
            f4 = paragraph6.add_run(self.check_empty(self.sheet.invoice_entry.get()))
            font = f4.font
            font.size = Pt(14)   
            f5 = paragraph6.add_run('    Order No: ')
            font = f5.font
            font.size = Pt(14)
            f5.bold = True
            f6 = paragraph6.add_run(self.check_empty(self.sheet.order_entry.get()))
            font = f6.font
            font.size = Pt(14)
            
            paragraph7 = document.add_paragraph()
            paragraph7.alignment = 1
            paragraph7.paragraph_format.space_before = Pt(1)
            f7 = paragraph7.add_run('    Required by: ')
            font = f7.font
            font.size = Pt(14)
            f7.bold = True
            f8 = paragraph7.add_run(self.check_empty(self.sheet.req_entry.get()))
            font = f8.font
            font.size = Pt(14)

            if sheet_type == 'trophy':
                document.add_picture(PATH + '\\Resources\\trophy_middle.png')
            elif sheet_type == 'engraving':
                document.add_picture(PATH + '\\Resources\\xengraving_middle.png')

            # get the number of entries to create the table
            number_of_entries = 0

            # the length of an empty text field is 1, so if the length is not 1, it is not empty and should be counted
            for i in range(len(self.sheet.qty_entries)):
                if len(self.sheet.qty_entries[i].get("1.0",END)) != 1:
                    number_of_entries += 1

            # create table based on sheet type
            if sheet_type == 'trophy':
                table = document.add_table(rows = (1 + number_of_entries), cols = 6)
                table.alignment = 1
                table.style = 'TableGrid'
                hdr_cells = table.rows[0].cells
                hdr_cells[0].text = 'QTY'
                hdr_cells[0].width = Cm(1)
                hdr_cells[1].text = 'TROPHY NO'
                hdr_cells[1].width = Cm(3)
                hdr_cells[2].text = 'SPORT'
                hdr_cells[2].width = Cm(5)
                hdr_cells[3].text = 'ENGRAVING DETAILS'
                hdr_cells[3].width = Cm(25)
                hdr_cells[4].text = 'UNIT PRICE'
                hdr_cells[4].width = Cm(2.5)
                hdr_cells[5].text = 'TOTAL'
                hdr_cells[5].width = Cm(2.5)

                # insert the given data into the table MUST HAVE QTY ENTERED FOR ALL ENTRIES
                for i in range(number_of_entries):
                    body_cells = table.rows[i+1].cells
                    body_cells[0].text = self.sheet.qty_entries[i].get("1.0",END)
                    body_cells[1].text = self.sheet.num_entries[i].get("1.0",END)
                    body_cells[2].text = self.sheet.sport_entries[i].get("1.0",END)
                    body_cells[3].text = self.sheet.details_entries[i].get("1.0",END)
                    body_cells[4].text = self.sheet.unit_entries[i].get("1.0",END)
                    body_cells[5].text = self.sheet.total_entries[i].get("1.0",END)
            
            elif sheet_type == 'engraving':
                table = document.add_table(rows = (2 + number_of_entries), cols = 2)
                table.alignment = 1
                table.style = 'TableGrid'
                hdr_cells = table.rows[0].cells
                hdr_cells[0].text = 'QTY'
                hdr_cells[0].width = Cm(1)
                hdr_cells[1].text = 'ENGRAVING DETAILS'
                hdr_cells[1].width = Cm(55)

                # insert the given data into the table MUST HAVE QTY ENTERED FOR ALL ENTRIES
                for i in range(number_of_entries):
                    body_cells = table.rows[i+1].cells
                    body_cells[0].text = self.sheet.qty_entries[i].get("1.0",END)
                    body_cells[1].text = self.sheet.details_entries[i].get("1.0",END)

                bottom_cells = table.rows[(number_of_entries + 1)].cells
                bottom_cells[1].text = 'Material size:                          Setup/Engrave time:                          Extra labour time:                          '

            document.add_picture(PATH + '\\Resources\\xspace.png')
            
            paragraph6 = document.add_paragraph()
            f1 = paragraph6.add_run('CUSTOMER APPROVAL   ')
            font = f1.font
            font.size = Pt(14)
            f1.bold = True
            f2 = paragraph6.add_run('                                                                                        Overall: $')
            font = f2.font
            font.size = Pt(14)
            f2.bold = True
            f3 = paragraph6.add_run(self.check_empty(self.sheet.overall_entry.get()))
            font = f3.font
            font.size = Pt(14)
            f3.bold = True
            
            unique_name = self.create_name(name)

            # check if signature has been created, if not give error message to confirm sheet has been signed
            try:
                document.add_picture(PATH + '\\Resources\\signature.png', width = Cm(5))
                try:
                    if name == '\n':
                        name == 'No name entered'
                    
                    # check if the folder exists, if not create it
                    if sheet_type == 'trophy':
                        if os.path.exists(PATH + '\\1. Job Sheets\\Trophy Jobsheets\\' + name):
                            document.save(PATH + '\\1. Job Sheets\\Trophy Jobsheets\\' + name + '\\' + unique_name + '.docx')
                        else:
                            os.makedirs(PATH + '\\1. Job Sheets\\Trophy Jobsheets\\' + name)
                            document.save(PATH + '\\1. Job Sheets\\Trophy Jobsheets\\' + name + '\\' + unique_name + '.docx')
                    
                    elif sheet_type == 'engraving':
                        if os.path.exists(PATH + '\\1. Job Sheets\\Engraving Jobsheets\\' + name):
                            document.save(PATH + '\\1. Job Sheets\\Engraving Jobsheets\\' + name + '\\' + unique_name + '.docx')
                        else:
                            os.makedirs(PATH + '\\1. Job Sheets\\Engraving Jobsheets\\' + name)
                            document.save(PATH + '\\1. Job Sheets\\Engraving Jobsheets\\' + name + '\\' + unique_name + '.docx')

                    self.save_data(name, unique_name)
                    self.open_doc(unique_name, name)
                    Calendar.save_to_calendar(self, self.sheet.req_entry.get(), unique_name, name, self.sheet.team_entry.get().lower())
                except:
                    window.pop_up_window('Error! Could not save file', 'Error')
                
                os.remove(PATH + '\\Resources\\signature.png')    
            except:
                window.pop_up_window('Error! Please confirm signature', 'Error')
                
    # open the requested document given the customers name and unique name    
    def open_doc(self, doc_name, folder_name):
        if doc_name[0] == 'T':
            try:
                os.startfile(PATH + '\\1. Job Sheets\\Trophy Jobsheets\\' + folder_name + '\\' + doc_name + '.docx')
            except:
                window.pop_up_window('Error! File could not be found', 'Error')
                      
        elif doc_name[0] == 'E':
            try:
                os.startfile(PATH + '\\1. Job Sheets\\Engraving Jobsheets\\' + folder_name + '\\' + doc_name + '.docx')
            except:
                window.pop_up_window('Error! File could not be found', 'Error')
        else:
            window.pop_up_window('Error! File must start with a T or E', 'Error')
    
    # create a unique name that contains the sheet type, date, customer name and a random 3 digit code
    def create_name(self, name): 
        cur_sheet = self.sheet.current_sheet
        
        if cur_sheet == 'trophy':
            start = 'T'
        else:
            start = 'E'
        
        name_date = self.sheet.date_entry.get()
        name_date_fixed = name_date.replace('/', '_')
        new_name = start + name_date_fixed + '_' + name + self.id_generator()
        fixed_new_name = new_name.replace(' ', '_')
        
        return fixed_new_name

    # generate random 3 digit code for job sheet name to make unique
    def id_generator(self, size=3, chars=string.ascii_uppercase + string.digits):
        return ''.join(random.choice(chars) for _ in range(size))

    # if field is empty, fill with spaces to allow for hand written entries
    def check_empty(self, entry):
        if entry == '':
            entry = '                '
        return entry

    # save all the entered data to autofill excel doc to enable autofilling previous orders
    def save_data(self, name, unique_name):
        try:
            # create a customer autofill excel doc if one doesn't exist
            if os.path.exists(PATH + '\\Data\\Autofill\\' + name + '\\autofill_data.xlsx'):    
                auto_f = load_workbook(PATH + '\\Data\\Autofill\\' + name + '\\autofill_data.xlsx')
            else:
                source = PATH + '\\Data\\Original\\autofill_data.xlsx'
                destination = PATH + '\\Data\\Autofill\\' + name
                os.makedirs(destination)
                shutil.copy(source, destination)
                auto_f = load_workbook(PATH + '\\Data\\Autofill\\' + name + '\\autofill_data.xlsx')
            
            auto_sheet = auto_f['Sheet1']
            new_row = auto_sheet.max_row + 1

            # on the next free row in the excel doc save the single entry data
            auto_sheet.cell(column=1, row=new_row, value=unique_name)
            auto_sheet.cell(column=2, row=new_row, value=self.sheet.req_entry.get())
            auto_sheet.cell(column=3, row=new_row, value=self.sheet.order_entry.get())
            auto_sheet.cell(column=4, row=new_row, value=self.sheet.invoice_entry.get())
            auto_sheet.cell(column=5, row=new_row, value=self.sheet.contact_entry.get())
            auto_sheet.cell(column=6, row=new_row, value=self.sheet.team_entry.get())
            auto_sheet.cell(column=7, row=new_row, value=self.sheet.overall_entry.get())

            # loop through the 20 trophy entries and save the data
            col = 8
            for i in range(20):
                auto_sheet.cell(column=i+col, row=new_row, value=self.sheet.qty_entries[i].get("1.0",END))
                auto_sheet.cell(column=i+3+col, row=new_row, value=self.sheet.details_entries[i].get("1.0",END))
                if self.sheet.current_sheet == 'trophy':
                    auto_sheet.cell(column=i+1+col, row=new_row, value=self.sheet.num_entries[i].get("1.0",END))
                    auto_sheet.cell(column=i+2+col, row=new_row, value=self.sheet.sport_entries[i].get("1.0",END))
                    auto_sheet.cell(column=i+4+col, row=new_row, value=self.sheet.unit_entries[i].get("1.0",END))
                    auto_sheet.cell(column=i+5+col, row=new_row, value=self.sheet.total_entries[i].get("1.0",END))
                col += 5
            
            # save and close the file
            auto_f.save(PATH + '\\Data\\Autofill\\' + name + '\\autofill_data.xlsx')
            auto_f.close()
        except:
            window.pop_up_window('Error! No autofill data file found', 'Error')

    # autofill the data from the excel doc
    def autofill(self, unique_name, name):
        
        auto_f = load_workbook(PATH + '\\Data\\Autofill\\' + name + '\\autofill_data.xlsx')
        auto_sheet = auto_f['Sheet1']
        last_row = auto_sheet.max_row
        self.autofill_data = []

        # iterate through the unique names until the required one is found, then append the data to autofill
        for i in range(last_row):
            if auto_sheet.cell(column=1, row=i+1).value == unique_name:
                self.autofill_data.append([auto_sheet.cell(column=j+1, row=i+1).value for j in range(127)])
        
        auto_f.close()

        # ensure there is data autofilled
        if self.autofill_data != []:
            try:
                # check for None values as they cause errors
                self.check_none_entry(1, self.sheet.req_entry)
                self.check_none_entry(2, self.sheet.order_entry)
                self.check_none_entry(3, self.sheet.invoice_entry)
                self.check_none_entry(4, self.sheet.contact_entry)
                self.check_none_entry(5, self.sheet.team_entry)
                self.check_none_entry(6, self.sheet.overall_entry)

                # loop through the 20 trophy entries and autofill the data, removing old data
                pos = 7
                for i in range(20):
                    self.check_none_text(pos, self.sheet.qty_entries[i])
                    self.check_none_text(pos+3, self.sheet.details_entries[i])
                    if self.sheet.current_sheet == 'trophy':
                        self.check_none_text(pos+1, self.sheet.num_entries[i])
                        self.check_none_text(pos+2, self.sheet.sport_entries[i])
                        self.check_none_text(pos+4, self.sheet.unit_entries[i])
                        self.check_none_text(pos+5, self.sheet.total_entries[i])
                    pos += 6
            except:
                window.pop_up_window('Error! You must select a sheet before autofilling', 'Error')
    
    # check that values aren't none to avoid errors
    def check_none_entry(self, position, field):
        field.delete(0,END)
        if self.autofill_data[0][position] != None:
            field.insert(0, self.autofill_data[0][position])

    # check that values aren't none to avoid errors
    def check_none_text(self, position, field):
        field.delete(1.0,END)
        if self.autofill_data[0][position] != None:
            field.insert(1.0, self.autofill_data[0][position])
    

if __name__ == "__main__":
    root = tk.Tk()
    root.geometry("1235x645")
    root.title("Geraldton Trophy Centre v5.0")
    root.configure(background='white')
    root.iconbitmap(PATH + '\\Resources\\Images\\logo.ico')

    window = Window(root)
    window.center(root)

    root.mainloop()
